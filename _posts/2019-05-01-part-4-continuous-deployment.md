---
layout: post
title: "Part 4: Continuous Deployment"
published: false
---

Fourth part in the series about Azure Functions in TypeScript. In this part the continuous integration pipeline is extended into a *continuous deployment* pipeline, where code pushed to GitHub is it automatically deployed to Azure. Until now the code has only been running locally. I do get that this is somewhat ironic since we are halfway into a series about cloud computing. We will remedy this now. While we could log in to the Azure Portal, create the necessary resources, and upload the code manually, we will deploy the hard way, by scripting everything so that get *infrastructure as code* where everything is checked into our source tree.

Azure's Asset Resource Management templates are tricky at first, but once you have used a setup with automated deployment, I guarantee that you will not want to go back to manual deployments. Automated deployment changes the way you think about software development. If you want to know more about this, the great Martin Fowler has a [series about continuous integration](https://martinfowler.com/articles/continuousIntegration.html) where he explains all the benefits.

You need to have an account on Azure. You can create one for free on [portal.azure.com](https://portal.azure.com/). If you're new to Azure I recommend that you try some of the manual tutorial out there to get a feel for how the portal works.

## Branch Environments

Each branch in our source code has an associated unique environment on Azure. New environments are automatically spawned when new branches are created. With such a setup there is are no specific development, test or staging environments, and the production environment is simply the one associated with the master branch.

In real world applications, the production environment would probably have more resources than the branch environments, and I guess that you could easily need a single official test environments for the final testing before go live of new feature. But in this tutorial we have the luxury of keeping all environments identical, thus simplifying the infrastructure code.

TODO: Make the master branch special, so that endpoint doesn't have a strange URL.

TODO: The production environment is not special in any regards. Well, except one thing: The name of the endpoint includes the word `production` instead of a hash.

Example:

- Brach name: `4-continuous-deployment`.
- Azure resource group name: `azure-functions-typescript-4-continuous-deployment`.
- Endpoint address for the Greet function: `https://aft-rgu2ohy42laos-functions.azurewebsites.net/api/greet/`.

The deployment process is done with four files:

- A bash script that creates the resource group and the resources on Azure.
- An [Azure Resource Manager (ARM) template](https://docs.microsoft.com/en-us/azure/azure-resource-manager/) that describes the resources.
- A bash script that copies the compiled code to Azure.
- A few extra steps in the CircleCI configuration file.

The ARM template is by far the biggest file.

## Naming Azure Resources

As you can tell from the length of the official [Naming conventions for Azure resources](https://docs.microsoft.com/en-us/azure/architecture/best-practices/naming-conventions), naming resources in Azure is surprising difficult.

Here are some of the caveats:

- Resource names have to be globally unique.
- There are different restrictions depending on the type of the resource.
- Some resources have very restrictive naming rules. (Storage accounts names can only be 24 characters long  and cannot contain any punctuation.)

`rgu2ohy42laos` is a globally unique string generated by `uniqueString(resourceGroup().id)` in the ARM template `azure-resources.json`. Azure requires that the names of the resources are globally unique, including storage accounts, that only allow up to 24 characters. With so few characters at our disposal---and no dots or hyphens---is not practical to prefix the name with a domain name or similar to avoid name collisions with other Azure users. [`uniqueString`](https://docs.microsoft.com/en-us/azure/azure-resource-manager/resource-group-template-functions-string#uniquestring) solves that, but with the downside that resource names look random instead of containing the name of the branch. The [naming convention for Azure resources](https://docs.microsoft.com/en-us/azure/architecture/best-practices/naming-conventions) only suggests using the unique string when naming storage accounts, but in this solution the string is used to name all the resources to keep the naming consistent across all resource types.

Creating the resources on Azure is done by the shell script [`create-azure-resources.sh`](https://github.com/janaagaard75/azure-functions-typescript/blob/4-continuous-deployment/deployment/create-azure-resources.sh) that uses the [Azure Command-Line Interface](https://docs.microsoft.com/en-us/cli/azure/?view=azure-cli-latest) (the `az` command). The resource group is created first, and then the resources described in `azure-template.json` are added to the group. The Azure CLI is idempotent, so calling the script multiple times is perfectly fine. The script runs faster if the resources already exist. If some resources have been modified, the Azure CLI will handle removing / changing / adding what is needed.

TODO: Can the structure be made briefer?

TODO: Highlights: Unique string

TODO: If you want to use branch names as environment names, you have to verify that the branch name can be used as a URL and verify that is doesn't already exist. You can't avoid invalid branch names (right?), but you can fail a test if before deployment happens.

```bash
# Part of create-azure-resources.sh

# Create a resource group.
resource_group_name="azure-functions-typescript-$1"
echo "Creating resource group $resource_group_name."
az group create \
  --location "northeurope" \
  --name $resource_group_name

# Create the resources.
script_folder="$( cd "$(dirname ${BASH_SOURCE[0]})"; pwd -P )"
template_file=$script_folder/azure-resources.json
now=`date +"%Y%m%d-%H%M%S"`
deployment_name="CircleCI-$now"
echo "Creating resources in resource group $resource_group_name with deployment $deployment_name."
az group deployment create \
  --mode Complete \
  --name $deployment_name \
  --resource-group $resource_group_name \
  --template-file $template_file \
  --verbose
```

## Asset Resource Management Template

The name of the resource group is derived from the branch name.

`uniqueString(resourceGroup().id)` is a unique 13 character string.

The arm template describes how set up the service plan, the storage account, Application Insights and the function apps.

- Same unique string in all of the resources names. No name collisions.
- Functions resource depend on th other three.
- Functions resource has properties that link it to the other resources. TODO: Explain precisely for all three.
- TODO: Link to the official help pages.
- TODO: Note about generating the template.

```javascript
// Structore of deployment/azure-resources.json
{
  "$schema": "https://schema.management.azure.com/schemas/2015-01-01/deploymentTemplate.json#",
  "contentVersion": "1.0.0.0",
  "variables": {
    // The names of the resoures are computed and store in variables.
    "appInsightsName": "[concat('aft-', uniqueString(resourceGroup().id), '-appinsights')]",
    // ...
  },
  "resources": [
    // Array with the four resources.
    {
      // TODO: What is the service plan?
      "type": "Microsoft.Web/serverfarms",
      // ...
    },
    {
      // The storage account is where the files are kept.
      "type": "Microsoft.Storage/storageAccounts",
      // ...
    },
    {
      // Application Insights tracks the functions.
      "type": "Microsoft.Insights/components",
      // ...
    },
    {
      // The website hosting the functions.
      "type": "Microsoft.Web/sites",
      // This resource depends on the three others.
      "dependsOn": [
        "[resourceId('Microsoft.Web/serverfarms', variables('servicePlanName'))]",
        "[resourceId('Microsoft.Storage/storageAccounts', variables('storageAccountName'))]",
        "[resourceId('Microsoft.Insights/components', variables('appInsightsName'))]"
      ],
      // ...
      "properties": {
        "siteConfig": {
          "appSettings": [
            {
              "name": "APPINSIGHTS_INSTRUMENTATIONKEY",
              "value": "[reference(concat('Microsoft.Insights/components/', variables('appInsightsName'))).InstrumentationKey]"
            },
            // ...
          ],
          // ...
        }
      }
    }
  ]
}
```

TODO: Show the full list of steps done, highlighting the new ones.

TODO: Note about installing Azure CLI on CircleCI.
TODO: Link to the code in the ORB, showing that it's quite complicated to install the CLI.

{% include figure.html
  src="/images/circleci-environment-variables.png"
  alt="Environment variables defined in CircleCI"
  caption="Define AZURE_USERNAME and AZURE_PASSWORD as environment variables in CircleCI."
%}

{% include figure.html
  src="/images/azure-resources.png"
  alt="Azure resources as shown on the Azure Portal"
  caption="Azure resources as shown on the Azure Portal."
%}

{% include previous-next.html
  previousHref="/blog/2019-05-01-part-3-local-test"
  previousText="Part 3: Local test"
  nextHref="/blog/2019-05-01-part-5-end-to-end-test"
  nextText="Part 5: End-to-end Test"
%}
